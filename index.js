/** @package        @cubo-cms/core
  * @version        0.0.1
  * @copyright      2020 Cubo CMS <https://cubo-cms.com/COPYRIGHT.md>
  * @license        MIT license <https://cubo-cms.com/LICENSE.md>
  * @author         Papiando <info@papiando.com>
  * @module         Namespace
  * @description    Static core class - Enables registering and loading modules
  **/
'use strict'

import fs from 'fs';
import path from 'path';

/** @module {class} Namespace
  *
  * Static core class - Enables registering and loading modules
  *   NOTE: Modules first need to be registered to load
  *   NOTE: This class creates global properties as detailed below
  *
  * @property {array} global.namespace - holds all loaded modules
  * @property {array} global.registry - holds all registered modules
  **/
export default class Namespace {
  /** @property {object} namespace - holds all loaded modules
    **/
  static namespace = {};
  /** @property {object} registry - holds all registered modules
    **/
  static registry = {};
  /** @property {object} default - holds default values
    **/
  static default = {
    extension: '.mjs',
    modulePath: './module'
  };
  /** @function loaded()
    *
    * Static getter function loaded - returns object of loaded modules
    *
    * @return {object}
    **/
  static get loaded() {
    return Namespace.namespace;
  }
  /** @function registered()
    *
    * Static getter function registered - returns object of registered modules
    *
    * @return {object}
    **/
  static get registered() {
    return Namespace.registry;
  }
  /** @function autoLoad()
    *
    * Static function autoLoad - Loads all registered modules
    *   NOTE: Uses autoRegister if no modules are registered yet
    *
    **/
  static async autoLoad(registry = undefined) {
    try {
      let promises = [];
      for(const moduleName of Object.keys(registry || Namespace.registry)) {
        promises.push(Namespace.load(moduleName));
      }
      await Promise.allSettled(promises);
      return Namespace.loaded;
    } catch(error) {
      console.error(error);
    }
  }
  /** @function autoRegister(path, dependency)
    *
    * Static function autoRegister - locates all modules in path and registers these
    *   NOTE: Names of subfolders are considered dependencies
    *
    * @param {string} path - path to browse; default if none given
    * @param {string} module - optional dependency; is autogenerated and should not be supplied
    * @return {object}
    **/
  static autoRegister(modulePath = Namespace.default.modulePath, dependency = undefined) {
    try {
      let files = fs.readdirSync(modulePath, { 'encoding': 'utf8', 'withFiletypes': true });
      for(const file of files) {
        if(fs.lstatSync(path.join(modulePath, file)).isDirectory()) {
          Namespace.autoRegister(path.join(modulePath, file), file)
        } else {
          Namespace.register({name: path.basename(file, path.extname(file)), path: './' + path.join(modulePath, file), dependency: dependency});
        }
      }
    } catch(error) {
      console.error(error);
    }
    return Namespace.registered;
  }
  /** @function isLoaded(module)
    *
    * Static function isLoaded - returns true if module is loaded
    *
    * @param {string} module - name of module
    * @return {bool}
    **/
  static isLoaded(moduleName) {
    return (typeof Namespace.namespace[moduleName] !== 'undefined');
  }
  /** @function isRegistered(module)
    *
    * Static function isRegistered - returns true if module is registered
    *
    * @param {string} module - name of module
    * @return {bool}
    **/
  static isRegistered(moduleName) {
    return (typeof Namespace.registry[moduleName] !== 'undefined');
  }
  /** @function load(module)
    *
    * Static asynchronous function load - returns a promise to load the module
    *
    * @param {string} module - name of module
    * @return {promise}
    **/
  static async load(moduleName) {
    try {
      if(Namespace.isLoaded(moduleName)) {
        return Namespace.namespace[moduleName];
      } else {
        let module;
        let registration = Namespace.registry[moduleName];
        if(registration.dependency) {
          await Namespace.load(registration.dependency);
        }
        module = await import(registration.path);
        return Namespace.namespace[moduleName] = Namespace[moduleName] = module.default;
      }
    } catch(error) {
      console.error(error);
    }
  }
  /** @function register(module)
    *
    * Static function register - returns the registration of the module
    *
    * @param {object} registration - object containing module registration info
    * @param {string} module - (optional) name of module; allows override/alias
    * @return {object}
    **/
  static register(registration, moduleName = null) {
    moduleName = moduleName || registration.name;
    registration.path = registration.path.replace(/\\/g, '/');
    return Namespace.registry[moduleName] = registration;
  }

/*
  autoload() => {
    for(let moduleName of Namespace.namespace.keys()) {
      global[moduleName] = Namespace.namespace[moduleName];
    }
  },
*/


}
