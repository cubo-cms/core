/** @package        @cubo-cms/core
  * @version        0.0.4
  * @copyright      2020 Cubo CMS <https://cubo-cms.com/COPYRIGHT.md>
  * @license        MIT license <https://cubo-cms.com/LICENSE.md>
  * @author         Papiando <info@papiando.com>
  * @module         Namespace
  * @description    Static namespace class - Enables registering and loading modules
  *                 into a common namespace
  **/

/** TODO:
  *   - Improve error checking of arguments, namely when registering and loading
  *   - Minimize the functions needed to import; check speed
  *   - Add functions to unregister and unload (might never be needed)
  **/

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

import FrameworkError from './FrameworkError.mjs';
import Log from './Log.mjs';

/** @module Namespace
  *
  * Static namespace class - Enables registering and loading modules
  * into a common namespace
  *   NOTE: Modules first need to be registered before loading
  *   NOTE: This class publishes loaded modules globally
  **/
export default class Namespace {
  /** @property {object} namespace - holds all loaded modules
    **/
  static namespace = {};
  /** @property {object} registry - holds all registered modules
    **/
  static registry = {};
  /** @property {object} default - holds default values
    **/
  static default = {
    publishGlobally: true,
    modulePath: 'module'
  };
  /** Static @function corePath()
    *
    * Static getter function corePath - returns the path to this module
    *
    * @return {string}
    **/
  static get corePath() {
    return path.dirname(fileURLToPath(import.meta.url));
  }
  /** Static @function loaded()
    *
    * Static getter function loaded - returns object of loaded modules
    *
    * @return {object}
    **/
  static get loaded() {
    return Namespace.namespace;
  }
  /** Static @function registered()
    *
    * Static getter function registered - returns object of registered modules
    *
    * @return {object}
    **/
  static get registered() {
    return Namespace.registry;
  }
  /** Static asynchronous @function autoLoad(registry)
    *
    * Static function autoLoad - Loads all registered modules
    *   NOTE: Uses autoRegister if no modules are registered yet
    *
    * @param {object} registry - optionally provide alternative registry
    * @return {object}
    **/
  static async autoLoad(registry = undefined) {
    try {
      let promises = [];
      for(const moduleName of Object.keys(registry || Namespace.registry)) {
        promises.push(Namespace.load(moduleName));
      }
      await Promise.allSettled(promises);
      Log.success({ message: `Completed autoloading of modules` });
      return Namespace.loaded;
    } catch(error) {
      Log.error({ message: `Failed to autoload modules` });
    }
  }
  /** Static @function autoRegister(path,dependency)
    *
    * Static function autoRegister - locates all modules in path and registers these
    *   NOTE: Names of subfolders are considered dependencies
    *
    * @param {string} path - path to browse; default if none given
    * @param {string} module - optional dependency; is autogenerated and should not be supplied
    * @return {object}
    **/
  static autoRegister(modulePath = Namespace.default.modulePath, basePath = '.', dependency = undefined) {
    try {
      let relPath = path.relative('.', path.resolve(basePath, modulePath));
      let files = fs.readdirSync(relPath, { 'encoding': 'utf8', 'withFiletypes': true });
      for(const file of files) {
        if(fs.lstatSync(path.join(relPath, file)).isDirectory()) {
          Namespace.autoRegister(path.join(modulePath, file), basePath, file)
        } else {
          Namespace.register({name: path.basename(file, path.extname(file)), path: './' + path.join(relPath, file), dependency: dependency});
        }
      }
      Log.success(`Completed autoregistering of modules`);
    } catch(error) {
      Log.error(`Failed to autoregister modules`);
    }
    return Namespace.registered;
  }
  /** Static @function isLoaded(module)
    *
    * Static function isLoaded - returns true if module is loaded
    *
    * @param {string} module - name of module
    * @return {bool}
    **/
  static isLoaded(moduleName) {
    return typeof Namespace.namespace[moduleName] !== 'undefined';
  }
  /** Static @function isRegistered(module)
    *
    * Static function isRegistered - returns true if module is registered
    *
    * @param {string} module - name of module
    * @return {bool}
    **/
  static isRegistered(moduleName) {
    return (typeof Namespace.registry[moduleName] !== 'undefined');
  }
  /** Static asynchronous @function load(module)
    *
    * Static asynchronous function load - returns a promise to load the module
    *
    * @param {string} module - name of module
    * @return {promise}
    **/
  static async load(moduleName) {
    try {
      if(Namespace.isLoaded(moduleName)) {
        throw new FrameworkError({ message: `Module \"${moduleName}\" was already loaded`, type: 'warning' });
        return Namespace.namespace[moduleName];
      } else if(Namespace.isRegistered(moduleName)) {
        let module;
        let registration = Namespace.registry[moduleName];
        if(registration.dependency) {
          await Namespace.load(registration.dependency);
        }
        module = await import('./' + path.relative(Namespace.corePath, registration.path));
        Namespace.namespace[moduleName] = Namespace[moduleName] = module.default;
        if(Namespace.default.publishGlobally) global[moduleName] = Namespace[moduleName];
        return Namespace[moduleName];
      } else {
        throw new FrameworkError({ message: `Module \"${moduleName}\" is not registered`, type: 'error' });
      }
    } catch(error) {
      new Log(error);
    }
  }
  /** Static @function register(module)
    *
    * Static function register - returns the registration of the module
    *
    * @param {object} registration - object containing module registration info
    * @param {string} module - (optional) name of module; allows override/alias
    * @return {object}
    **/
  static register(registration, moduleName = undefined) {
    moduleName = moduleName || registration.name;
    return Namespace.registry[moduleName] = registration;
  }
}
